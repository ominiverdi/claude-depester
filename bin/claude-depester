#!/usr/bin/env node

/**
 * claude-depester CLI
 * Remove silly thinking words from Claude Code
 *
 * @author Lorenzo Becchi (https://github.com/ominiverdi)
 * @license MIT
 */

const { findCliJs, findAllClaudeCode, getSearchedPaths } = require('../lib/detector');
const { patch, checkStatus, getDebugInfo, restoreBackup } = require('../lib/patcher');
const { installHook, removeHook, getHookStatus, searchHookLogs, appendLog, readLog, LOG_PATH } = require('../lib/hooks');

const VERSION = require('../package.json').version;

// Parse arguments
const args = process.argv.slice(2);
const flags = {
  help: args.includes('--help') || args.includes('-h'),
  version: args.includes('--version') || args.includes('-v'),
  check: args.includes('--check') || args.includes('-c'),
  restore: args.includes('--restore') || args.includes('-r'),
  dryRun: args.includes('--dry-run') || args.includes('-n'),
  installHook: args.includes('--install-hook'),
  removeHook: args.includes('--remove-hook'),
  hookStatus: args.includes('--hook-status'),
  silent: args.includes('--silent') || args.includes('-s'),
  verbose: args.includes('--verbose'),
  debug: args.includes('--debug') || args.includes('-d'),
  log: args.includes('--log'),
  all: args.includes('--all') || args.includes('-a'),
  list: args.includes('--list') || args.includes('-l')
};

function log(...msg) {
  if (!flags.silent) {
    console.log(...msg);
  }
}

function error(...msg) {
  console.error(...msg);
}

function formatPatchDetails(result) {
  const parts = [];
  if (result.spinnerCount > 0) {
    parts.push(`spinner(${result.spinnerCount})`);
  }
  if (result.completionCount > 0) {
    parts.push(`completion(${result.completionCount})`);
  }
  return parts.length > 0 ? ` [${parts.join(' + ')}]` : '';
}

function showHelp() {
  console.log(`
claude-depester v${VERSION}

Remove silly thinking words from Claude Code (like "Flibbertigibbeting", 
"Discombobulating", etc.) and replace them with "Thinking".

USAGE:
  npx claude-depester [options]

OPTIONS:
  (no options)      Patch Claude Code now
  -a, --all         Patch ALL installations (CLI + VS Code extensions)
  -l, --list        List all found installations
  -c, --check       Check if Claude Code is patched
  -r, --restore     Restore original file from backup
  -n, --dry-run     Preview changes without applying
  
  --install-hook    Add SessionStart hook (auto-patch after updates)
  --remove-hook     Remove SessionStart hook
  --hook-status     Check if hook is installed
  
  -s, --silent      Suppress output (for hook use)
  --verbose         Show detailed information
  -d, --debug       Show detailed debug info (for troubleshooting)
  --log             Write results to ~/.claude/depester.log (keeps last 50 entries)
  -v, --version     Show version
  -h, --help        Show this help

EXAMPLES:
  npx claude-depester                 # Patch first found installation
  npx claude-depester --all           # Patch ALL installations
  npx claude-depester --list          # List all installations
  npx claude-depester --check         # Check status
  npx claude-depester --install-hook  # Auto-patch after updates
  npx claude-depester --restore       # Undo patch
  npx claude-depester --debug         # Troubleshoot issues

MORE INFO:
  https://github.com/ominiverdi/claude-depester
`);
}

function showVersion() {
  console.log(`claude-depester v${VERSION}`);
}

function showSearchedPaths() {
  error('\nSearched paths:');
  for (const { method, path } of getSearchedPaths()) {
    error(`  [${method}]`);
    error(`    ${path}`);
  }
}

async function main() {
  // Handle help/version first
  if (flags.help) {
    showHelp();
    process.exit(0);
  }
  
  if (flags.version) {
    showVersion();
    process.exit(0);
  }
  
  // Handle hook management (doesn't require finding cli.js)
  if (flags.hookStatus) {
    const status = getHookStatus();
    log(`Hook installed: ${status.installed ? 'yes' : 'no'}`);
    log(`Settings file: ${status.settingsPath}`);
    process.exit(0);
  }
  
  if (flags.installHook) {
    const result = installHook();
    log(result.message);
    process.exit(result.success ? 0 : 1);
  }
  
  if (flags.removeHook) {
    const result = removeHook();
    log(result.message);
    process.exit(result.success ? 0 : 1);
  }
  
  // Handle --list
  if (flags.list) {
    const installations = findAllClaudeCode();
    if (installations.length === 0) {
      error('No Claude Code installations found.');
      if (flags.verbose) {
        showSearchedPaths();
      }
      process.exit(1);
    }
    
    log(`Found ${installations.length} installation(s):\n`);
    for (const inst of installations) {
      const status = checkStatus(inst.path, { type: inst.type });
      const statusStr = status.patched ? '[PATCHED]' : '[NOT PATCHED]';
      // Use actual detected type from status, not the detector's guess
      const typeStr = status.isWebview ? ' (webview)' : status.isBinary ? ' (binary)' : '';
      log(`${statusStr} ${inst.method}${typeStr}`);
      log(`  ${inst.path}\n`);
    }
    process.exit(0);
  }
  
  // Handle --all (patch all installations)
  if (flags.all) {
    const installations = findAllClaudeCode();
    if (installations.length === 0) {
      error('No Claude Code installations found.');
      if (flags.log) {
        appendLog('No installations found', { action: 'patch-all' });
      }
      if (flags.verbose) {
        showSearchedPaths();
      }
      process.exit(1);
    }
    
    log(`Found ${installations.length} installation(s):\n`);
    
    let successCount = 0;
    let skipCount = 0;
    let failCount = 0;
    const logResults = [];
    
    for (const inst of installations) {
      log(`${inst.method}:`);
      log(`  ${inst.path}`);
      
      if (flags.restore) {
        const success = restoreBackup(inst.path);
        if (success) {
          log('  -> Restored from backup\n');
          successCount++;
          logResults.push({ path: inst.path, method: inst.method, result: 'restored' });
        } else {
          log('  -> No backup found\n');
          skipCount++;
          logResults.push({ path: inst.path, method: inst.method, result: 'no-backup' });
        }
      } else {
        // Get debug info before patching for the log
        const debugBefore = flags.log ? getDebugInfo(inst.path, { type: inst.type }) : null;
        
        const result = patch(inst.path, { dryRun: flags.dryRun, type: inst.type });
        if (result.success) {
          if (result.alreadyPatched) {
            log('  -> Already patched\n');
            skipCount++;
            logResults.push({ 
              path: inst.path, 
              method: inst.method, 
              result: 'already-patched',
              debug: debugBefore
            });
          } else if (result.dryRun) {
            const details = formatPatchDetails(result);
            log(`  -> Would patch${details}\n`);
            successCount++;
            logResults.push({ path: inst.path, method: inst.method, result: 'dry-run' });
          } else {
            const details = formatPatchDetails(result);
            log(`  -> Patched${details}\n`);
            successCount++;
            logResults.push({ 
              path: inst.path, 
              method: inst.method, 
              result: 'patched',
              spinnerCount: result.spinnerCount,
              completionCount: result.completionCount,
              debug: debugBefore
            });
          }
        } else {
          log(`  -> Failed: ${result.message}\n`);
          failCount++;
          logResults.push({ 
            path: inst.path, 
            method: inst.method, 
            result: 'failed', 
            error: result.message,
            debug: debugBefore
          });
        }
      }
    }
    
    log(`Done: ${successCount} patched, ${skipCount} skipped, ${failCount} failed`);
    if (!flags.dryRun && successCount > 0) {
      log('Restart Claude Code for changes to take effect.');
    }
    
    if (flags.log) {
      appendLog('Patch all completed', {
        action: 'patch-all',
        found: installations.length,
        patched: successCount,
        skipped: skipCount,
        failed: failCount,
        results: logResults
      });
    }
    
    process.exit(failCount > 0 ? 1 : 0);
  }
  
  // Find Claude Code installation (single)
  const cliInfo = findCliJs();
  
  if (!cliInfo) {
    error('Could not find Claude Code installation.');
    if (flags.verbose) {
      showSearchedPaths();
    } else {
      error('Run with --verbose to see searched paths.');
    }
    error('\nMake sure Claude Code is installed:');
    error('  https://code.claude.com/docs/en/setup');
    process.exit(1);
  }
  
  if (flags.verbose) {
    log(`Found Claude Code: ${cliInfo.path}`);
    log(`Detection method: ${cliInfo.method}`);
  }
  
  // Handle debug
  if (flags.debug) {
    log('=== DEPESTER DEBUG INFO ===\n');
    
    // Get debug info for all installations
    const installations = findAllClaudeCode();
    if (installations.length === 0) {
      log('No installations found.\n');
    } else {
      for (const inst of installations) {
        const debug = getDebugInfo(inst.path, { type: inst.type });
        
        log(`--- ${inst.method} ---`);
        log(`Path: ${debug.filePath}`);
        log(`File exists: ${debug.fileExists}`);
        if (debug.fileExists) {
          log(`File size: ${debug.fileSize} bytes`);
          log(`File modified: ${debug.fileModified}`);
          log(`Is binary: ${debug.isBinary}`);
          log(`Is webview: ${debug.isWebview}`);
          if (debug.isBinary) {
            log(`Binary extraction OK: ${debug.binaryExtractionOk}`);
            if (debug.extractedJsSize) {
              log(`Extracted JS size: ${debug.extractedJsSize} bytes`);
            }
          }
          log(`Has backup: ${debug.hasBackup}`);
          log('');
          log('Detection checks:');
          log(`  Has =["Thinking"]: ${debug.hasReplacementPattern}`);
          log(`  Has =["Thought"]: ${debug.hasCompletionReplacement}`);
          log(`  Has original spinner array: ${debug.hasOriginalSpinnerArray}`);
          log(`  Has original completion array: ${debug.hasOriginalCompletionArray}`);
          log(`  Marker words found: ${debug.markerWordsFound.length > 0 ? debug.markerWordsFound.join(', ') : 'none'}`);
          log(`  Completion verbs found: ${debug.completionVerbsFound.length > 0 ? debug.completionVerbsFound.join(', ') : 'none'}`);
          log('');
          log('Computed status:');
          log(`  Spinner patched: ${debug.spinnerPatched}`);
          log(`  Completion patched: ${debug.completionPatched}`);
          log(`  Has silly words: ${debug.hasSillyWords}`);
        }
        if (debug.error) {
          log(`Error: ${debug.error}`);
        }
        log('');
      }
    }
    
    // Hook status
    const hookStatus = getHookStatus();
    log('--- Hook Status ---');
    log(`Hook installed: ${hookStatus.installed}`);
    log(`Settings file: ${hookStatus.settingsPath}`);
    log('');
    
    // Search Claude debug logs for hook activity
    log('--- Recent Hook Activity (from Claude logs) ---');
    const hookLogs = searchHookLogs(5);
    if (hookLogs.length === 0) {
      log('No hook activity found in recent Claude debug logs.');
    } else {
      for (const logFile of hookLogs) {
        log(`\nLog: ${logFile.file} (${logFile.timestamp})`);
        for (const entry of logFile.entries) {
          log(`  ${entry.time}: ${entry.message}`);
        }
      }
    }
    log('');
    
    // Show depester's own log
    log('--- Depester Log (last 10 entries) ---');
    log(`Log file: ${LOG_PATH}`);
    const depesterLogs = readLog();
    if (depesterLogs.length === 0) {
      log('No entries. Enable logging with --log flag.');
    } else {
      const recent = depesterLogs.slice(-10);
      for (const entry of recent) {
        log(`\n${entry.timestamp}: ${entry.message}`);
        if (entry.data) {
          if (entry.data.found !== undefined) {
            log(`  Found: ${entry.data.found}, Patched: ${entry.data.patched}, Skipped: ${entry.data.skipped}, Failed: ${entry.data.failed}`);
          }
          // Only show per-installation details if there was a failure or unexpected result
          if (entry.data.results) {
            const hasIssue = entry.data.results.some(r => 
              r.result === 'failed' || 
              (r.result === 'already-patched' && r.debug?.markerWordsFound?.length > 0)
            );
            if (hasIssue) {
              for (const r of entry.data.results) {
                log(`  - ${r.method}: ${r.result}`);
                if (r.debug) {
                  log(`    File modified: ${r.debug.fileModified}`);
                  log(`    Has =["Thinking"]: ${r.debug.hasReplacementPattern}`);
                  log(`    Marker words: ${r.debug.markerWordsFound?.length > 0 ? r.debug.markerWordsFound.join(', ') : 'none'}`);
                }
                if (r.error) {
                  log(`    Error: ${r.error}`);
                }
              }
            }
          }
        }
      }
    }
    log('');
    
    process.exit(0);
  }
  
  // Handle check
  if (flags.check) {
    const status = checkStatus(cliInfo.path, { type: cliInfo.type });
    
    if (status.error) {
      error(`Error: ${status.error}`);
      process.exit(1);
    }
    
    if (status.patched) {
      log('Status: PATCHED');
      log('Silly words have been replaced with "Thinking"');
    } else if (status.hasSillyWords) {
      log('Status: NOT PATCHED');
      log('Silly words are present. Run without --check to patch.');
    } else {
      log('Status: UNKNOWN');
      log('Could not find silly words array. Version may not be supported.');
    }
    
    if (status.hasBackup) {
      log('Backup: available (can restore with --restore)');
    }
    
    const hookStatus = getHookStatus();
    log(`Auto-patch hook: ${hookStatus.installed ? 'installed' : 'not installed'}`);
    
    process.exit(status.patched ? 0 : 1);
  }
  
  // Handle restore
  if (flags.restore) {
    const success = restoreBackup(cliInfo.path);
    if (success) {
      log('Restored original file from backup.');
      log('Restart Claude Code for changes to take effect.');
    } else {
      error('No backup found. Cannot restore.');
      process.exit(1);
    }
    process.exit(0);
  }
  
  // Default action: patch
  const result = patch(cliInfo.path, { dryRun: flags.dryRun, type: cliInfo.type });
  
  if (result.success) {
    if (result.alreadyPatched) {
      log('Already patched. Nothing to do.');
    } else if (result.dryRun) {
      log('DRY RUN - no changes made:');
      log(result.message);
    } else {
      log('Patched successfully!');
      log('Silly words replaced with "Thinking".');
      log('Restart Claude Code for changes to take effect.');
      
      // Suggest installing hook
      const hookStatus = getHookStatus();
      if (!hookStatus.installed) {
        log('\nTip: Run with --install-hook to auto-patch after updates.');
      }
    }
    process.exit(0);
  } else {
    error(`Failed: ${result.message}`);
    if (flags.verbose) {
      showSearchedPaths();
    }
    process.exit(1);
  }
}

main().catch(err => {
  error(`Unexpected error: ${err.message}`);
  process.exit(1);
});
