#!/usr/bin/env node

/**
 * claude-depester CLI
 * Remove silly thinking words from Claude Code
 *
 * @author Lorenzo Becchi (https://github.com/ominiverdi)
 * @license MIT
 */

const { findAllClaudeCode, getSearchedPaths } = require('../lib/detector');
const { patch, checkStatus, getDebugInfo, restoreBackup } = require('../lib/patcher');
const { installHook, removeHook, getHookStatus, searchHookLogs, appendLog, readLog, LOG_PATH } = require('../lib/hooks');

const VERSION = require('../package.json').version;

// Parse arguments
const args = process.argv.slice(2);
const flags = {
  help: args.includes('--help') || args.includes('-h'),
  version: args.includes('--version') || args.includes('-v'),
  check: args.includes('--check') || args.includes('-c'),
  restore: args.includes('--restore') || args.includes('-r'),
  dryRun: args.includes('--dry-run') || args.includes('-n'),
  installHook: args.includes('--install-hook'),
  removeHook: args.includes('--remove-hook'),
  hookStatus: args.includes('--hook-status'),
  silent: args.includes('--silent') || args.includes('-s'),
  verbose: args.includes('--verbose'),
  debug: args.includes('--debug') || args.includes('-d'),
  log: args.includes('--log'),
  list: args.includes('--list') || args.includes('-l'),
  // --all is accepted silently for backwards compatibility (all is now the default)
};

// Parse --path <file>
let pathOverride = null;
const pathIdx = args.indexOf('--path');
if (pathIdx !== -1 && args[pathIdx + 1]) {
  pathOverride = args[pathIdx + 1];
}

function log(...msg) {
  if (!flags.silent) {
    console.log(...msg);
  }
}

function error(...msg) {
  console.error(...msg);
}

function formatPatchDetails(result) {
  const parts = [];
  if (result.spinnerCount > 0) {
    parts.push(`spinner(${result.spinnerCount})`);
  }
  if (result.completionCount > 0) {
    parts.push(`completion(${result.completionCount})`);
  }
  return parts.length > 0 ? ` [${parts.join(' + ')}]` : '';
}

function showHelp() {
  console.log(`
claude-depester v${VERSION}

Remove silly thinking words from Claude Code (like "Flibbertigibbeting", 
"Discombobulating", etc.) and replace them with "Thinking".

USAGE:
  npx claude-depester [options]

OPTIONS:
  (no options)      Patch all Claude Code installations
  -l, --list        List all found installations and their status
  -c, --check       Check patch status of all installations
  -r, --restore     Restore all installations from backup
  -n, --dry-run     Preview changes without applying
  --path <file>     Target a specific file instead of auto-detecting
  
  --install-hook    Add SessionStart hook (auto-patch after updates)
  --remove-hook     Remove SessionStart hook
  --hook-status     Check if hook is installed
  
  -s, --silent      Suppress output (for hook use)
  --verbose         Show detailed information
  -d, --debug       Show detailed debug info (for troubleshooting)
  --log             Write results to ~/.claude/depester.log (keeps last 50 entries)
  -v, --version     Show version
  -h, --help        Show this help

EXAMPLES:
  npx claude-depester                 # Patch all installations
  npx claude-depester --list          # Show all installations and status
  npx claude-depester --check         # Check status
  npx claude-depester --restore       # Undo all patches
  npx claude-depester --install-hook  # Auto-patch after updates
  npx claude-depester --dry-run       # Preview without patching
  npx claude-depester --path ./claude # Patch a specific file
  npx claude-depester --debug         # Troubleshoot issues

MORE INFO:
  https://github.com/ominiverdi/claude-depester
`);
}

function showVersion() {
  console.log(`claude-depester v${VERSION}`);
}

function showSearchedPaths() {
  error('\nSearched paths:');
  for (const { method, path } of getSearchedPaths()) {
    error(`  [${method}]`);
    error(`    ${path}`);
  }
}

/**
 * Find installations to operate on.
 * If --path is given, returns a single-item array for that path.
 * Otherwise, returns all auto-detected installations.
 */
function getInstallations() {
  if (pathOverride) {
    const fs = require('fs');
    if (!fs.existsSync(pathOverride)) {
      error(`File not found: ${pathOverride}`);
      process.exit(1);
    }
    return [{ path: pathOverride, method: `--path ${pathOverride}`, type: undefined }];
  }
  return findAllClaudeCode();
}

async function main() {
  // Handle help/version first
  if (flags.help) {
    showHelp();
    process.exit(0);
  }
  
  if (flags.version) {
    showVersion();
    process.exit(0);
  }
  
  // Handle hook management (doesn't require finding cli.js)
  if (flags.hookStatus) {
    const status = getHookStatus();
    log(`Hook installed: ${status.installed ? 'yes' : 'no'}`);
    log(`Settings file: ${status.settingsPath}`);
    process.exit(0);
  }
  
  if (flags.installHook) {
    const result = installHook();
    log(result.message);
    process.exit(result.success ? 0 : 1);
  }
  
  if (flags.removeHook) {
    const result = removeHook();
    log(result.message);
    process.exit(result.success ? 0 : 1);
  }
  
  // Handle --debug (shows info for all installations)
  if (flags.debug) {
    log('=== DEPESTER DEBUG INFO ===\n');
    
    const installations = findAllClaudeCode();
    if (installations.length === 0) {
      log('No installations found.\n');
    } else {
      for (const inst of installations) {
        const debug = getDebugInfo(inst.path, { type: inst.type });
        
        log(`--- ${inst.method} ---`);
        log(`Path: ${debug.filePath}`);
        log(`File exists: ${debug.fileExists}`);
        if (debug.fileExists) {
          log(`File size: ${debug.fileSize} bytes`);
          log(`File modified: ${debug.fileModified}`);
          log(`Is binary: ${debug.isBinary}`);
          log(`Is webview: ${debug.isWebview}`);
          if (debug.isBinary) {
            log(`Binary extraction OK: ${debug.binaryExtractionOk}`);
            if (debug.extractedJsSize) {
              log(`Extracted JS size: ${debug.extractedJsSize} bytes`);
            }
          }
          log(`Has backup: ${debug.hasBackup}`);
          log('');
          log('Detection checks:');
          log(`  Has =["Thinking"]: ${debug.hasReplacementPattern}`);
          log(`  Has =["Thought"]: ${debug.hasCompletionReplacement}`);
          log(`  Has original spinner array: ${debug.hasOriginalSpinnerArray}`);
          log(`  Has original completion array: ${debug.hasOriginalCompletionArray}`);
          log(`  Marker words found: ${debug.markerWordsFound.length > 0 ? debug.markerWordsFound.join(', ') : 'none'}`);
          log(`  Completion verbs found: ${debug.completionVerbsFound.length > 0 ? debug.completionVerbsFound.join(', ') : 'none'}`);
          log('');
          log('Computed status:');
          log(`  Spinner patched: ${debug.spinnerPatched}`);
          log(`  Completion patched: ${debug.completionPatched}`);
          log(`  Has silly words: ${debug.hasSillyWords}`);
        }
        if (debug.error) {
          log(`Error: ${debug.error}`);
        }
        log('');
      }
    }
    
    // Hook status
    const hookStatus = getHookStatus();
    log('--- Hook Status ---');
    log(`Hook installed: ${hookStatus.installed}`);
    log(`Settings file: ${hookStatus.settingsPath}`);
    log('');
    
    // Search Claude debug logs for hook activity
    log('--- Recent Hook Activity (from Claude logs) ---');
    const hookLogs = searchHookLogs(5);
    if (hookLogs.length === 0) {
      log('No hook activity found in recent Claude debug logs.');
    } else {
      for (const logFile of hookLogs) {
        log(`\nLog: ${logFile.file} (${logFile.timestamp})`);
        for (const entry of logFile.entries) {
          log(`  ${entry.time}: ${entry.message}`);
        }
      }
    }
    log('');
    
    // Show depester's own log
    log('--- Depester Log (last 10 entries) ---');
    log(`Log file: ${LOG_PATH}`);
    const depesterLogs = readLog();
    if (depesterLogs.length === 0) {
      log('No entries. Enable logging with --log flag.');
    } else {
      const recent = depesterLogs.slice(-10);
      for (const entry of recent) {
        log(`\n${entry.timestamp}: ${entry.message}`);
        if (entry.data) {
          if (entry.data.found !== undefined) {
            log(`  Found: ${entry.data.found}, Patched: ${entry.data.patched}, Skipped: ${entry.data.skipped}, Failed: ${entry.data.failed}`);
          }
          if (entry.data.results) {
            const hasIssue = entry.data.results.some(r => 
              r.result === 'failed' || 
              (r.result === 'already-patched' && r.debug?.markerWordsFound?.length > 0)
            );
            if (hasIssue) {
              for (const r of entry.data.results) {
                log(`  - ${r.method}: ${r.result}`);
                if (r.debug) {
                  log(`    File modified: ${r.debug.fileModified}`);
                  log(`    Has =["Thinking"]: ${r.debug.hasReplacementPattern}`);
                  log(`    Marker words: ${r.debug.markerWordsFound?.length > 0 ? r.debug.markerWordsFound.join(', ') : 'none'}`);
                }
                if (r.error) {
                  log(`    Error: ${r.error}`);
                }
              }
            }
          }
        }
      }
    }
    log('');
    
    process.exit(0);
  }
  
  // Find installations
  const installations = getInstallations();
  if (installations.length === 0) {
    error('No Claude Code installations found.');
    if (flags.log) {
      appendLog('No installations found', { action: flags.check ? 'check' : flags.restore ? 'restore' : 'patch' });
    }
    if (flags.verbose) {
      showSearchedPaths();
    } else {
      error('Run with --verbose to see searched paths.');
    }
    process.exit(1);
  }
  
  // Handle --list
  if (flags.list) {
    log(`Found ${installations.length} installation(s):\n`);
    for (const inst of installations) {
      const status = checkStatus(inst.path, { type: inst.type });
      const statusStr = status.patched ? '[PATCHED]' : '[NOT PATCHED]';
      const typeStr = status.isWebview ? ' (webview)' : status.isBinary ? ' (binary)' : '';
      log(`${statusStr} ${inst.method}${typeStr}`);
      log(`  ${inst.path}\n`);
    }
    process.exit(0);
  }
  
  // Handle --check
  if (flags.check) {
    let allPatched = true;
    let anyError = false;
    
    if (installations.length > 1) {
      log(`Found ${installations.length} installation(s):\n`);
    }
    
    for (const inst of installations) {
      const status = checkStatus(inst.path, { type: inst.type });
      
      if (status.error) {
        error(`${inst.method}: Error - ${status.error}`);
        anyError = true;
        continue;
      }
      
      if (installations.length > 1) {
        const statusStr = status.patched ? 'PATCHED' : 'NOT PATCHED';
        log(`[${statusStr}] ${inst.method}`);
        log(`  ${inst.path}`);
        if (status.hasBackup) log('  Backup: available');
        log('');
      } else {
        if (status.patched) {
          log('Status: PATCHED');
          log('Silly words have been replaced with "Thinking"');
        } else if (status.hasSillyWords) {
          log('Status: NOT PATCHED');
          log('Silly words are present. Run without --check to patch.');
        } else {
          log('Status: UNKNOWN');
          log('Could not find silly words array. Version may not be supported.');
        }
        if (status.hasBackup) {
          log('Backup: available (can restore with --restore)');
        }
      }
      
      if (!status.patched) allPatched = false;
    }
    
    const hookStatus = getHookStatus();
    log(`Auto-patch hook: ${hookStatus.installed ? 'installed' : 'not installed'}`);
    
    process.exit(allPatched && !anyError ? 0 : 1);
  }
  
  // Handle --restore
  if (flags.restore) {
    if (installations.length > 1) {
      log(`Found ${installations.length} installation(s):\n`);
    }
    
    let successCount = 0;
    let failCount = 0;
    
    for (const inst of installations) {
      const success = restoreBackup(inst.path);
      if (installations.length > 1) {
        log(`${inst.method}:`);
        log(`  ${inst.path}`);
      }
      if (success) {
        if (installations.length > 1) {
          log('  -> Restored from backup\n');
        } else {
          log('Restored original file from backup.');
        }
        successCount++;
      } else {
        if (installations.length > 1) {
          log('  -> No backup found\n');
        } else {
          error('No backup found. Cannot restore.');
        }
        failCount++;
      }
    }
    
    if (successCount > 0) {
      log('Restart Claude Code for changes to take effect.');
    }
    process.exit(failCount > 0 && successCount === 0 ? 1 : 0);
  }
  
  // Default action: patch all installations
  if (installations.length > 1 || flags.verbose) {
    log(`Found ${installations.length} installation(s):\n`);
  }
  
  let successCount = 0;
  let skipCount = 0;
  let failCount = 0;
  const logResults = [];
  
  for (const inst of installations) {
    if (installations.length > 1 || flags.verbose) {
      log(`${inst.method}:`);
      log(`  ${inst.path}`);
    }
    
    const debugBefore = flags.log ? getDebugInfo(inst.path, { type: inst.type }) : null;
    
    const result = patch(inst.path, { dryRun: flags.dryRun, type: inst.type });
    if (result.success) {
      if (result.alreadyPatched) {
        if (installations.length > 1 || flags.verbose) {
          log('  -> Already patched\n');
        }
        skipCount++;
        logResults.push({ 
          path: inst.path, method: inst.method, result: 'already-patched', debug: debugBefore
        });
      } else if (result.dryRun) {
        const details = formatPatchDetails(result);
        if (installations.length > 1 || flags.verbose) {
          log(`  -> Would patch${details}\n`);
        } else {
          log(`DRY RUN - would patch${details}`);
          log(result.message);
        }
        successCount++;
        logResults.push({ path: inst.path, method: inst.method, result: 'dry-run' });
      } else {
        const details = formatPatchDetails(result);
        if (installations.length > 1 || flags.verbose) {
          log(`  -> Patched${details}\n`);
        }
        successCount++;
        logResults.push({ 
          path: inst.path, method: inst.method, result: 'patched',
          spinnerCount: result.spinnerCount, completionCount: result.completionCount,
          debug: debugBefore
        });
      }
    } else {
      if (installations.length > 1 || flags.verbose) {
        log(`  -> Failed: ${result.message}\n`);
      } else {
        error(`Failed: ${result.message}`);
      }
      failCount++;
      logResults.push({ 
        path: inst.path, method: inst.method, result: 'failed', error: result.message,
        debug: debugBefore
      });
    }
  }
  
  // Summary
  if (successCount > 0 && !flags.dryRun) {
    if (skipCount === 0 && failCount === 0 && installations.length === 1) {
      log('Patched successfully!');
      log('Silly words replaced with "Thinking".');
    } else if (installations.length > 1) {
      log(`Done: ${successCount} patched, ${skipCount} already patched, ${failCount} failed`);
    }
    log('Restart Claude Code for changes to take effect.');
    
    const hookStatus = getHookStatus();
    if (!hookStatus.installed) {
      log('\nTip: Run with --install-hook to auto-patch after updates.');
    }
  } else if (skipCount > 0 && successCount === 0 && failCount === 0) {
    log('Already patched. Nothing to do.');
  }
  
  if (flags.log) {
    appendLog('Patch completed', {
      action: flags.dryRun ? 'dry-run' : 'patch',
      found: installations.length,
      patched: successCount,
      skipped: skipCount,
      failed: failCount,
      results: logResults
    });
  }
  
  process.exit(failCount > 0 ? 1 : 0);
}

main().catch(err => {
  error(`Unexpected error: ${err.message}`);
  process.exit(1);
});
